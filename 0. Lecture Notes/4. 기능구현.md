# 기능 구현 순서 및 개발 방식

## 1. 기능 구현 순서

### 🧑‍💻 실무 기준 
1. 인증 기능 
2. 데이터 비연동기능
3. 데이터 연동기능
4. API 연동 기능
5. 병렬 처리

> 실무에서는 **인증 기능을 먼저 구현**하는 것이 일반적  
> 이유: 전체 시스템 접근 구조를 먼저 설계해야 하기 때문

### 🎓 학습(강의) 기준
1. 데이터 비연동기능
2. 데이터 연동기능
3. API 연동 기능
4. 인증 기능 
5. 병렬 처리

> 강의에서는 인증 기능이 뒤로!  
> 이유: 데이터 흐름(비연동 → 연동 → API)을 이해해야 인증 구현이 가능하기 때문

## 2. 기능 구현이 바이브 코딩으로 가능하게 된 핵심 요인

| 구분 | 역할 |
|------|------|
| **피그마 MCP (UI)** | UI 구조를 자동으로 인식 및 반영 |
| **TDD + AutoMode (기능)** | 기능 개발을 자동화하고 안정성 확보 |

## 3. TDD와 AutoMode

### ✅ TDD (Test Driven Development)

- **테스트 코드를 먼저 작성**하고 테스트를 통과하도록 기능을 구현하는 개발 방식
- 일반적으로 `test.ts` 또는 `spec.ts` 파일로 작성
- 하나의 기능에 하나의 테스트를 연결하여 **쌍으로 작동**시킴


### ⚙️ AutoMode
- **Cursor AI 설정 중 하나**
- 브라우저 실행, 파일 생성/삭제 등 **로컬 접근이 필요한 작업을 자동화**
- 사용자의 승인 없이도 자체적으로 실행 가능
- TDD와 함께 사용 시, **사람처럼 개발**하며 **결과적 안정성**을 크게 높일 수 있음


## 4. 테스트 종류

| 테스트 유형 | 설명 | 예시 도구 |
|--------------|------|------------|
| **단위 테스트 (Unit Test)** | 기능 1개를 독립적으로 검증 | Jest |
| **통합 테스트 (Integration Test)** | 여러 기능이 함께 동작하는지 검증 | Jest, Supertest |
| **E2E 테스트 (End-to-End Test)** | 실제 유저 행동을 시뮬레이션 | Playwright |

## 5. 사전 준비

### ▶️ Playwright 주의 사항
- Playwright는 테스트를 돌릴 때 **브라우저 창을 실제로 띄우지 않고, 보이지 않는 상태로 실행**할 수 있음. 이런 방식을 **headless(헤드리스) 모드**라고 부르며, 화면은 안 보이지만 내부적으로는 실제 브라우저가 그대로 작동하고 있음.
- Playwright는 **Chromium, WebKit, Firefox** 등의 브라우저 **바이너리(실행 파일)** 를 사용. (Chromium은 Chromium 엔진 기반 브라우저 — Chrome과 동일 소스 계열이지만 Playwright가 번들로 제공하는 빌드)
- Playwright 버전마다 연결되는(호환되는) 브라우저 바이너리 버전이 고정되어 있거나 변경되므로, **OS·환경(예: Windows 버전)** 과 맞춰서 설치/검증하는 것이 중요!! 특히 CI나 오래된 OS에서는 의존성/바이너리 문제 발생 가능성이 있음.

### Playwright 설치 

1. **OS 정보** 및 **권장 버전** 확인: `o3` 모델로 아래와 같이 물어보고 안정적인 버전 확인 (o3는 복잡하고 여러운 내용 답 잘해줌. but, 시간 오래 걸림)

    ```nginx
    내 Windows OS가 몇 버전인지 확인하고, 여기에 브라우저 충돌이 나지 않는 Playwright 버전(권장 안정 버전)을 알려줘.
    ```

2. 실제 **설치 명령**(버전 고정): 위에서 확인한 내용으로 `claude-4-sonnet` 모델 에게 설치 명령

    ```nginx
    Playwright 1.39.2 버전으로 @playwright/test(또는 playwright) 설치 및 기본 셋업 명령을 알려줘. 예제 테스트 파일은 만들지 말아줘.
    ``` 

3. 설치 확인 및 설정 수정

- `playwright.config.ts` 생성 확인 및 설정 수정 (일부 부분은 설정은 끄고 진행. 이 설정 값에 따라 실패할 수도 성공할 수도 있어서 주석 처리하여 실행 예정)

```ts
export default defineConfig({
  // testDir: './tests',
  // fullyParallel: true,
  // forbidOnly: !!process.env.CI,
  // retries: process.env.CI ? 2 : 0,
  // workers: process.env.CI ? 1 : undefined,
  // reporter: 'html',
  use: {
    baseURL: 'http://localhost:3000', // 이 브라우저로 접속해서 실제 버튼 누르고 테스트 진행해줘 라는 뜻.

    // trace: 'on-first-retry',
  },

  // 어떤 브라우저 키고 테스트 할것인지
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },

    // {
    //   name: 'firefox',
    //   use: { ...devices['Desktop Firefox'] },
    // },

    // {
    //   name: 'webkit',
    //   use: { ...devices['Desktop Safari'] },
    // },

    /* Test against mobile viewports. */
    // {
    //   name: 'Mobile Chrome',
    //   use: { ...devices['Pixel 5'] },
    // },
    // {
    //   name: 'Mobile Safari',
    //   use: { ...devices['iPhone 12'] },
    // },

    /* Test against branded browsers. */
    // {
    //   name: 'Microsoft Edge',
    //   use: { ...devices['Desktop Edge'], channel: 'msedge' },
    // },
    // {
    //   name: 'Google Chrome',
    //   use: { ...devices['Desktop Chrome'], channel: 'chrome' },
    // },
  ],

  /* Run your local dev server before starting the tests */
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI,
  },
});

```

- `package.json`에 아래와 같이 명령어 추가된 것 확인
```json
"script": {
  ...
  "test:e2e": "playwright test",
  "test:e2e:ui": "playwright test --ui",
  "test:e2e:headed": "playwright test --headed",
  "test:e2e:debug": "playwright test --debug",
  ...
}
```

4. root 밑에 `tests` 폴더 생겼다면 삭제

<details>

<summary>Playwright 직접 설치 방법</summary>

- [공식문서](https://playwright.dev/docs/browsers?utm_source=chatgpt.com)

1. Windows 버전 확인 (PowerShell 방식)
  ```powershell
  Get-CimInstance -ClassName Win32_OperatingSystem | Select-Object Caption, Version
  ```
2. Playwright Test(테스트 러너 포함) 특정 버전 설치
  ```bash
  npm install -D @playwright/test@1.39.2
  ```

3. 브라우저 바이너리 설치
  ```bash
  npx playwright install
  ```

4. 설치 확인 방법
- `playwright.config.ts` 파일이 프로젝트 루트에 있는지 확인
  - 생성되었다면 기본 설정(테스트 디렉터리, 리포터 등)이 들어있음. 
- `package.json`에 실행 스크립트(예: "test": "playwright test")가 추가되었는지 확인
- Playwright 버전 확인:
  ```bash
  npx playwright --version
  ```
</details>

### Cursor의 Auto-Run 기능 셋팅

1. Cursor 오른쪽 위의 톱니바퀴 눌러서 셋팅 실행

2. 왼쪽 메뉴에서 `Chat` 선택 > `Auto-Run`으로 이동

3. 아래와 동일한지 확인

    - `Auto-Run Mode`: Run Everything
    - `Playwright Protection`: enable
    - `File-Deletion Protection`: enable
    - `Dotfile Protection`: enable
    - `External-File Deletion`: enable

<br/>

# 데이터 비연동기능
- 페이지 이동(링크) 연결
- 상세 배너 연동
- 모달(버튼) 연동

### 1. 폴더구조 (예시)
- 필요한 폴더 생성

  ```bash
  📂 프로젝트 루트
  ├── 📂 src                       
  │   ├── 📂 commons               
  │   │   ├── 📂 components          
  │   │   ├── 📂 constants         
  │   │   ├── 📂 layout                               
  │   │   │   ├── 📂 prompts                      
  │   │   │   │   ├── 📄 prompt.101.wireframe.txt 
  │   │   │   │   ├── 📄 prompt.201.ui.txt 
  │   │   │   │   ├── 📄 prompt.301.func.link.routing.txt # 추가
  │   │   ├── 📄 index.tsx                         
  │   │   ├── 📄 styles.module.css                 
  │   │
  ```

### 2. 프롬프트 텍스트 파일
- 필요한 프롬프트 텍스트 파일을 해당 기능과 연관된 곳에 추가
  - [페이지 이동(링크) 연결](4.%20기능구현/prompt.301.func.link.routing.txt)
  - [상세 배너 연동](4.%20기능구현/prompt.302.func.area.txt)
  - [모달(버튼) 연동](4.%20기능구현/prompt.301.func.link.modal.txt)

### 3. 프롬프트 텍스트 파일 내용 작성
- 프롬프트 텍스트 파일 내용 작성 및 필요한 파일 생성 *ex. index.link.routing.hook.ts*

  - **조건-커서룰**:
    - [@01-common.mdc](1.%20공통요소/1-1.%20Rules%20파일/01-common.mdc)
    - [@04-func.mdc](1.%20공통요소/1-1.%20Rules%20파일/04-func.mdc)
  - **파일경로**:
    - 이미 UI 만들 때 만들었던 파일:
      - `src/commons/layout/index.tsx`
      - `src/commons/layout/styles.module.css`
    - 추가로 만들어야 하는 파일(기능 추가 부분을 구현하는 파일): 
      - `src/commons/layout/hooks/index.link.routing.hook.ts`
      - `src/commons/layout/tests/index.link.routing.hook.spec.ts`
  - **핵심요구사항**: *← Rules에도 테스트 조건 있지만, 그것 말고도 이 기능을 만들때 추가적으로 붙어야 할 테스트 조건 사항*
    - 다음의 기능을 playwright 테스트를 활용하여 TDD기반으로 구현할 것.
      - 테스트 제외 라이브러리 명시 *← Playwright 쓸것임*
      - 테스트 조건:
        - timeout은 설정하지 않거나, 500ms 미만으로 설정할 것. *←테스트는 API 를 제외하고는 timeout 테스트 안함. 왜냐면, 이건 내부 링크 이동이라서 굳이 timeout 테스트 필요없음* 
        - 페이지가 완전히 로드된 후 테스트할 것. *←버튼 그려지지도 않았는데, 테스트 진행 할 순 없으므로. 그럼, 완전히 로드 된걸 어떻게 알 수 있을 것인가를 알려주기 위해서 아래 상황 명시*
          - 페이지 로드 식별 요구사항: 고정식별자 data-testid 대기 방법
          - 페이지 로드 식별 금지사항: networkidle 대기 방법 *← 식별 금지인 이유는 채팅과 같은 서버랑 계속 통신하는 페이지에서는 에러가 발생할 수 있기 때문*
        - 테스트 skip 대상 *← 아직 사진 보관함 페이지 만들지 않았으므로 테스트 대상 아님. 이건 정해진게 아니라 개발 구현 순서에 따라 유연하게 조정*
          - /pictures
      - 기능 구현 조건: 
        - layout의 각 영역을 클릭시, url.ts의 페이지URL에 정의된 경로로 이동할 것. *← 이미 만들어져 있는 페이지/URL 명시* 

### 4. recheck 룰 검토
- 기능 구현 단계에서는 실제로 실행 후 모든 작업이 완료되면 "룰 재검토 해줘" 등의 명령을 개별적으로 입력하지 않음.   
- 이 과정에서는 채팅창을 검토하지 않고 기능을 구현해야, 이후 병렬적으로 기능 개발이 가능.   
- 단, 아래의 recheck 룰 절차를 모두 수행했음에도 불구하고 비정상적인 결과가 발생할 수 있음.   
- 그럴 경우에는 해당 커밋을 삭제하고 재실행 필요.

#### 룰 검토 순서
1. 해당 프롬프트 실행
2. **Required Recheck Rules** 실행
  - 채팅창에 `[@recheck.101.required.rule.mdc](1.%20공통요소/1-1.%20Rules%20파일/recheck.101.required.rule.mdc) 요청` 입력하여 첫번째 리체크 룰 실행 
  - 채팅창에 `[@recheck.102.required.codestyle.mdc](1.%20공통요소/1-1.%20Rules%20파일/recheck.102.required.codestyle.mdc) 요청` 입력하여 두번째 리체크 룰 실행
3. **Optional Recheck Rules** 실행 (필요한걸 선택하여 진행)
  - 채팅창에 `[@recheck.201.optional.ui.component.mdc](1.%20공통요소/1-1.%20Rules%20파일/recheck.201.optional.ui.component.mdc) 요청` 입력하여 첫번째 리체크 룰 실행
  - 채팅창에 `[@recheck.202.optional.ui.mock.mdc](1.%20공통요소/1-1.%20Rules%20파일/recheck.202.optional.ui.mock.mdc) 요청` 입력하여 두번째 리체크 룰 실행
  - 채팅창에 `[@recheck.301.optional.func.test.mdc](1.%20공통요소/1-1.%20Rules%20파일/recheck.301.optional.func.test.mdc) 요청` 입력하여 세번째 리체크 룰 실행
  - 채팅창에 `[@recheck.302.optional.func.alltest.mdc](1.%20공통요소/1-1.%20Rules%20파일/recheck.302.optional.func.alltest.mdc) 요청` 입력하여 네번째 리체크 룰 실행
4. **Required Final Rechck Rule** 실행
  - 채팅창에 `[@recheck.401.required.final.mdc](1.%20공통요소/1-1.%20Rules%20파일/recheck.401.required.final.mdc) 요청` 입력하여 리체크 룰 실행

### 5.  기능 실제로 확인 및 수정
- 기능이 제대로 구현이 잘 되었는지 확인
- 기능에 문제가 있다면 **F12(개발자모드)** 로 확인하여 프롬프트 수정하여 제대로 작동할 때 까지 진행
- 기능 수정할 때 무조건 프롬프트로 요청해야 하는건 아니고, 매우 간단해서 바로 고칠 수 있다면 바로 고쳐도 무관 (좀 더 효율적인 방법 선택)
- 만약 비정상적인 결과가 발생한다면, 해당 커밋을 삭제하고 재실행하는게 빠른 경우도 있음

### 6. recheck 룰 재검토
- 기능은 앞으로 병렬로 돌릴 것이기 때문에, 한쪽면만 보지말고 전체를 봐야함 
- 따라서, recheck 룰 재검토 필요
- [4. recheck 룰 검토](#recheck-룰-재검토) 부분 재실행

<br/>

# 데이터 연동 기능
- 폼
- 데이터 바인딩

### 1. 폴더구조 (예시)
- 필요한 폴더 생성

  ```bash
  📂 프로젝트 루트
  ├── 📂 src                       
  │   ├── 📂 commons               
  │   │   ├── 📂 components          
  │   │   ├── 📂 modal                               
  │   │   │   ├── 📂 prompts                      
  │   │   │   │   ├── 📄 prompt.101.ui.txt 
  │   │   │   │   ├── 📄 prompt.201.stories.txt 
  │   │   ├── 📄 index.tsx                         
  │   │   ├── 📄 styles.module.css                 
  │   │
  ```

TODO: 여기서 부터 수정

### 2. 프롬프트 텍스트 파일
- 필요한 프롬프트 텍스트 파일을 해당 기능과 연관된 곳에 추가
  - [페이지 이동(링크) 연결](4.%20기능구현/prompt.301.func.link.routing.txt)
  - [상세 배너 연동](4.%20기능구현/prompt.302.func.area.txt)
  - [모달(버튼) 연동](4.%20기능구현/prompt.301.func.link.modal.txt)

### 3. 프롬프트 텍스트 파일 내용 작성
- 프롬프트 텍스트 파일 내용 작성 및 필요한 파일 생성 *ex. index.link.routing.hook.ts*

### 4. recheck 룰 검토


### 5.  기능 실제로 확인 및 수정

### 6. recheck 룰 재검토



# API 연동 기능
- 외부 공개 API
- 내부 백엔드 API

# 인증 기능
- 로그인
- 회원가입

# 병렬 처리
- 독립적인 기능 선별: 메인페이지 기능, 상세페이지 기능.