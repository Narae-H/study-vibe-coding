# 기능 구현 순서 및 개발 방식

## 1. 기능 구현 순서

### 🧑‍💻 실무 기준 
1. 인증 기능 
2. 데이터 비연동기능
3. 데이터 연동기능
4. API 연동 기능
5. 병렬 처리

> 실무에서는 **인증 기능을 먼저 구현**하는 것이 일반적  
> 이유: 전체 시스템 접근 구조를 먼저 설계해야 하기 때문

### 🎓 학습(강의) 기준
1. 데이터 비연동기능
2. 데이터 연동기능
3. API 연동 기능
4. 인증 기능 
5. 병렬 처리

> 강의에서는 인증 기능이 뒤로!  
> 이유: 데이터 흐름(비연동 → 연동 → API)을 이해해야 인증 구현이 가능하기 때문

## 2. 기능 구현이 바이브 코딩으로 가능하게 된 핵심 요인

| 구분 | 역할 |
|------|------|
| **피그마 MCP (UI)** | UI 구조를 자동으로 인식 및 반영 |
| **TDD + AutoMode (기능)** | 기능 개발을 자동화하고 안정성 확보 |

## 3. TDD와 AutoMode

### ✅ TDD (Test Driven Development)

- **테스트 코드를 먼저 작성**하고 테스트를 통과하도록 기능을 구현하는 개발 방식
- 일반적으로 `test.ts` 또는 `spec.ts` 파일로 작성
- 하나의 기능에 하나의 테스트를 연결하여 **쌍으로 작동**시킴


### ⚙️ AutoMode
- **Cursor AI 설정 중 하나**
- 브라우저 실행, 파일 생성/삭제 등 **로컬 접근이 필요한 작업을 자동화**
- 사용자의 승인 없이도 자체적으로 실행 가능
- TDD와 함께 사용 시, **사람처럼 개발**하며 **결과적 안정성**을 크게 높일 수 있음


## 4. 테스트 종류

| 테스트 유형 | 설명 | 예시 도구 |
|--------------|------|------------|
| **단위 테스트 (Unit Test)** | 기능 1개를 독립적으로 검증 | Jest |
| **통합 테스트 (Integration Test)** | 여러 기능이 함께 동작하는지 검증 | Jest, Supertest |
| **E2E 테스트 (End-to-End Test)** | 실제 유저 행동을 시뮬레이션 | Playwright |

## 5. 사전 준비

### ▶️ Playwright 주의 사항
- Playwright는 테스트를 돌릴 때 **브라우저 창을 실제로 띄우지 않고, 보이지 않는 상태로 실행**할 수 있음. 이런 방식을 **headless(헤드리스) 모드**라고 부르며, 화면은 안 보이지만 내부적으로는 실제 브라우저가 그대로 작동하고 있음.
- Playwright는 **Chromium, WebKit, Firefox** 등의 브라우저 **바이너리(실행 파일)** 를 사용. (Chromium은 Chromium 엔진 기반 브라우저 — Chrome과 동일 소스 계열이지만 Playwright가 번들로 제공하는 빌드)
- Playwright 버전마다 연결되는(호환되는) 브라우저 바이너리 버전이 고정되어 있거나 변경되므로, **OS·환경(예: Windows 버전)** 과 맞춰서 설치/검증하는 것이 중요!! 특히 CI나 오래된 OS에서는 의존성/바이너리 문제 발생 가능성이 있음.

### Playwright 설치 

1. **OS 정보** 및 **권장 버전** 확인: `o3` 모델로 아래와 같이 물어보고 안정적인 버전 확인 (o3는 복잡하고 여러운 내용 답 잘해줌. but, 시간 오래 걸림)

    ```nginx
    내 Windows OS가 몇 버전인지 확인하고, 여기에 브라우저 충돌이 나지 않는 Playwright 버전(권장 안정 버전)을 알려줘.
    ```

2. 실제 **설치 명령**(버전 고정): 위에서 확인한 내용으로 `claude-4-sonnet` 모델 에게 설치 명령

    ```nginx
    Playwright 1.39.2 버전으로 @playwright/test(또는 playwright) 설치 및 기본 셋업 명령을 알려줘. 예제 테스트 파일은 만들지 말아줘.
    ``` 

3. 설치 확인 및 설정 수정

- `playwright.config.ts` 생성 확인 및 설정 수정 (일부 부분은 설정은 끄고 진행. 이 설정 값에 따라 실패할 수도 성공할 수도 있어서 주석 처리하여 실행 예정)

```ts
export default defineConfig({
  // testDir: './tests',
  // fullyParallel: true,
  // forbidOnly: !!process.env.CI,
  // retries: process.env.CI ? 2 : 0,
  // workers: process.env.CI ? 1 : undefined,
  // reporter: 'html',
  use: {
    baseURL: 'http://localhost:3000', // 이 브라우저로 접속해서 실제 버튼 누르고 테스트 진행해줘 라는 뜻.

    // trace: 'on-first-retry',
  },

  // 어떤 브라우저 키고 테스트 할것인지
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },

    // {
    //   name: 'firefox',
    //   use: { ...devices['Desktop Firefox'] },
    // },

    // {
    //   name: 'webkit',
    //   use: { ...devices['Desktop Safari'] },
    // },

    /* Test against mobile viewports. */
    // {
    //   name: 'Mobile Chrome',
    //   use: { ...devices['Pixel 5'] },
    // },
    // {
    //   name: 'Mobile Safari',
    //   use: { ...devices['iPhone 12'] },
    // },

    /* Test against branded browsers. */
    // {
    //   name: 'Microsoft Edge',
    //   use: { ...devices['Desktop Edge'], channel: 'msedge' },
    // },
    // {
    //   name: 'Google Chrome',
    //   use: { ...devices['Desktop Chrome'], channel: 'chrome' },
    // },
  ],

  /* Run your local dev server before starting the tests */
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI,
  },
});

```

- `package.json`에 아래와 같이 명령어 추가된 것 확인
```json
"script": {
  ...
  "test:e2e": "playwright test",
  "test:e2e:ui": "playwright test --ui",
  "test:e2e:headed": "playwright test --headed",
  "test:e2e:debug": "playwright test --debug",
  ...
}
```

4. root 밑에 `tests` 폴더 생겼다면 삭제

<details>

<summary>Playwright 직접 설치 방법</summary>

- [공식문서](https://playwright.dev/docs/browsers?utm_source=chatgpt.com)

1. Windows 버전 확인 (PowerShell 방식)
  ```powershell
  Get-CimInstance -ClassName Win32_OperatingSystem | Select-Object Caption, Version
  ```
2. Playwright Test(테스트 러너 포함) 특정 버전 설치
  ```bash
  npm install -D @playwright/test@1.39.2
  ```

3. 브라우저 바이너리 설치
  ```bash
  npx playwright install
  ```

4. 설치 확인 방법
- `playwright.config.ts` 파일이 프로젝트 루트에 있는지 확인
  - 생성되었다면 기본 설정(테스트 디렉터리, 리포터 등)이 들어있음. 
- `package.json`에 실행 스크립트(예: "test": "playwright test")가 추가되었는지 확인
- Playwright 버전 확인:
  ```bash
  npx playwright --version
  ```
</details>

### Cursor의 Auto-Run 기능 셋팅

1. Cursor 오른쪽 위의 톱니바퀴 눌러서 셋팅 실행

2. 왼쪽 메뉴에서 `Chat` 선택 > `Auto-Run`으로 이동

3. 아래와 동일한지 확인

    - `Auto-Run Mode`: Run Everything
    - `Playwright Protection`: enable
    - `File-Deletion Protection`: enable
    - `Dotfile Protection`: enable
    - `External-File Deletion`: enable

<br/>

# 데이터 비연동기능
- 페이지 이동(링크) 연결
- 상세 배너 연동
- 모달(버튼) 연동

### 1. 폴더구조 (예시)
- 필요한 폴더 생성

  ```bash
  📂 프로젝트 루트
  ├── 📂 src                       
  │   ├── 📂 commons               
  │   │   ├── 📂 components          
  │   │   ├── 📂 constants         
  │   │   ├── 📂 layout                               
  │   │   │   ├── 📂 prompts                      
  │   │   │   │   ├── 📄 prompt.101.wireframe.txt 
  │   │   │   │   ├── 📄 prompt.201.ui.txt 
  │   │   │   │   ├── 📄 prompt.301.func.link.routing.txt # 추가
  │   │   ├── 📄 index.tsx                         
  │   │   ├── 📄 styles.module.css                 
  │   │
  ```

### 2. 프롬프트 텍스트 파일
- 필요한 프롬프트 텍스트 파일을 해당 기능과 연관된 곳에 추가
  - [페이지 이동(링크) 연결](4.%20기능구현/1-1.%20데이터%20비연동%20파일/prompt.301.func.link.routing.txt)
  - [상세 배너 연동](4.%20기능구현/1-1.%20데이터%20비연동%20파일/prompt.302.func.area.txt)
  - [모달(버튼) 연동](4.%20기능구현/1-1.%20데이터%20비연동%20파일/prompt.301.func.link.modal.txt)

### 3. 프롬프트 텍스트 파일 내용 작성
- 프롬프트 텍스트 파일 내용 작성 및 필요한 파일 생성 *ex. index.link.routing.hook.ts*

  - **조건-커서룰**:
    - [@01-common.mdc](1.%20공통요소/1-1.%20Rules%20파일/01-common.mdc)
    - [@04-func.mdc](1.%20공통요소/1-1.%20Rules%20파일/04-func.mdc)
  - **파일경로**:
    - 이미 UI 만들 때 만들었던 파일:
      - `src/commons/layout/index.tsx`
      - `src/commons/layout/styles.module.css`
    - 추가로 만들어야 하는 파일(기능 추가 부분을 구현하는 파일): 
      - `src/commons/layout/hooks/index.link.routing.hook.ts`
      - `src/commons/layout/tests/index.link.routing.hook.spec.ts`
  - **핵심요구사항**: *← Rules에도 테스트 조건 있지만, 그것 말고도 이 기능을 만들때 추가적으로 붙어야 할 테스트 조건 사항*
    - 다음의 기능을 playwright 테스트를 활용하여 TDD기반으로 구현할 것.
      - 테스트 제외 라이브러리 명시 *← Playwright 쓸것임*
      - 테스트 조건:
        - timeout은 설정하지 않거나, 500ms 미만으로 설정할 것. *←테스트는 API 를 제외하고는 timeout 테스트 안함. 왜냐면, 이건 내부 링크 이동이라서 굳이 timeout 테스트 필요없음* 
        - 페이지가 완전히 로드된 후 테스트할 것. *←버튼 그려지지도 않았는데, 테스트 진행 할 순 없으므로. 그럼, 완전히 로드 된걸 어떻게 알 수 있을 것인가를 알려주기 위해서 아래 상황 명시*
          - 페이지 로드 식별 요구사항: 고정식별자 data-testid 대기 방법
          - 페이지 로드 식별 금지사항: networkidle 대기 방법 *← 식별 금지인 이유는 채팅과 같은 서버랑 계속 통신하는 페이지에서는 에러가 발생할 수 있기 때문*
        - 테스트 skip 대상 *← 아직 사진 보관함 페이지 만들지 않았으므로 테스트 대상 아님. 이건 정해진게 아니라 개발 구현 순서에 따라 유연하게 조정*
          - /pictures
      - 기능 구현 조건: 
        - layout의 각 영역을 클릭시, url.ts의 페이지URL에 정의된 경로로 이동할 것. *← 이미 만들어져 있는 페이지/URL 명시* 

### 4. recheck 룰 검토
- 기능 구현 단계에서는 실제로 실행 후 모든 작업이 완료되면 "룰 재검토 해줘" 등의 명령을 개별적으로 입력하지 않음.   
- 이 과정에서는 채팅창을 검토하지 않고 기능을 구현해야, 이후 병렬적으로 기능 개발이 가능.   
- 단, 아래의 recheck 룰 절차를 모두 수행했음에도 불구하고 비정상적인 결과가 발생할 수 있음.   
- 그럴 경우에는 해당 커밋을 삭제하고 재실행 필요.

#### 룰 검토 순서
1. 해당 프롬프트 실행
2. **Required Recheck Rules** 실행
  - 채팅창에 `[@recheck.101.required.rule.mdc](1.%20공통요소/1-1.%20Rules%20파일/recheck.101.required.rule.mdc) 요청` 입력하여 첫번째 리체크 룰 실행 
  - 채팅창에 `[@recheck.102.required.codestyle.mdc](1.%20공통요소/1-1.%20Rules%20파일/recheck.102.required.codestyle.mdc) 요청` 입력하여 두번째 리체크 룰 실행
3. **Optional Recheck Rules** 실행 (필요한걸 선택하여 진행)
  - 채팅창에 `[@recheck.201.optional.ui.component.mdc](1.%20공통요소/1-1.%20Rules%20파일/recheck.201.optional.ui.component.mdc) 요청` 입력하여 첫번째 리체크 룰 실행
  - 채팅창에 `[@recheck.202.optional.ui.mock.mdc](1.%20공통요소/1-1.%20Rules%20파일/recheck.202.optional.ui.mock.mdc) 요청` 입력하여 두번째 리체크 룰 실행
  - 채팅창에 `[@recheck.301.optional.func.test.mdc](1.%20공통요소/1-1.%20Rules%20파일/recheck.301.optional.func.test.mdc) 요청` 입력하여 세번째 리체크 룰 실행
  - 채팅창에 `[@recheck.302.optional.func.alltest.mdc](1.%20공통요소/1-1.%20Rules%20파일/recheck.302.optional.func.alltest.mdc) 요청` 입력하여 네번째 리체크 룰 실행
4. **Required Final Rechck Rule** 실행
  - 채팅창에 `[@recheck.401.required.final.mdc](1.%20공통요소/1-1.%20Rules%20파일/recheck.401.required.final.mdc) 요청` 입력하여 리체크 룰 실행

### 5.  기능 실제로 확인 및 수정
- 기능이 제대로 구현이 잘 되었는지 확인
- 기능에 문제가 있다면 **F12(개발자모드)** 로 확인하여 프롬프트 수정하여 제대로 작동할 때 까지 진행
- 기능 수정할 때 무조건 프롬프트로 요청해야 하는건 아니고, 매우 간단해서 바로 고칠 수 있다면 바로 고쳐도 무관 (좀 더 효율적인 방법 선택)
- 만약 비정상적인 결과가 발생한다면, 해당 커밋을 삭제하고 재실행하는게 빠른 경우도 있음

### 6. recheck 룰 재검토
- 기능은 앞으로 병렬로 돌릴 것이기 때문에, 한쪽면만 보지말고 전체를 봐야함 
- 따라서, recheck 룰 재검토 필요
- [4. recheck 룰 검토](#recheck-룰-재검토) 부분 재실행

<br/>

# 데이터 연동 기능
- 폼 생성
- 데이터 바인딩

### 1. 폴더구조 (예시)
- 필요한 폴더 및 파일 생성
- `prompt.101.ui.txt` 를 통해서 `index.tsx`, `styles.module.css` 먼저 생성하고, 그 다음에 `prompt.201.stories.txt` 이걸 써서 스토리북(`index.stories.txt`) 생성하기. 그래야 빌드 에러 안남.

  ```bash
  📂 프로젝트 루트
  ├── 📂 src                       
  │   ├── 📂 commons               
  │   │   ├── 📂 components          
  │   │   ├── 📂 modal                               
  │   │   │   ├── 📂 prompts                      
  │   │   │   │   ├── 📄 prompt.101.ui.txt       # 추가
  │   │   │   │   ├── 📄 prompt.201.stories.txt  # 추가
  │   │   ├── 📄 index.tsx                       # 추가   
  │   │   ├── 📄 styles.module.css               # 추가  
  │   │
  ```

### 2. 프롬프트 텍스트 파일
- 필요한 프롬프트 텍스트 파일을 해당 기능과 연관된 곳에 추가
  - [모달 생성](4.%20기능구현/1-2.%20데이터%20연동%20파일/prompt.101.ui.txt)
  - [모달 스토리북 생성](4.%20기능구현/1-2.%20데이터%20연동%20파일/prompt.201.stories.txt)

### 3. 프롬프트 텍스트 파일 내용 작성

- 프롬프트 텍스트 파일 내용 작성 및 필요한 파일 생성 

  - **조건-커서룰**:
    - [@01-common.mdc](1.%20공통요소/1-1.%20Rules%20파일/01-common.mdc)
    - [@02-wireframe.mdc](1.%20공통요소/1-1.%20Rules%20파일/02-wireframe.mdc)
    - [@03-ui.mdc](1.%20공통요소/1-1.%20Rules%20파일/03-ui.mdc)
  - **파일경로**:
    - 추가로 만들어야 하는 파일(기능 추가 부분을 구현하는 파일): 
      - `src/commons/components/modal/index.tsx`
      - `src/commons/components/modal/styles.module.css`
  - **핵심요구사항**: *← Rules에도 테스트 조건 있지만, 그것 말고도 이 기능을 만들때 추가적으로 붙어야 할 테스트 조건 사항*
    - 다음의 기능을 playwright 테스트를 활용하여 TDD기반으로 구현할 것.
      - 테스트 제외 라이브러리 명시 *← Playwright 쓸것임*
      - 테스트 조건:
        - timeout은 설정하지 않거나, 500ms 미만으로 설정할 것. *←테스트는 API 를 제외하고는 timeout 테스트 안함. 왜냐면, 이건 내부 링크 이동이라서 굳이 timeout 테스트 필요없음* 
        - 페이지가 완전히 로드된 후 테스트할 것. *←버튼 그려지지도 않았는데, 테스트 진행 할 순 없으므로. 그럼, 완전히 로드 된걸 어떻게 알 수 있을 것인가를 알려주기 위해서 아래 상황 명시*
          - 페이지 로드 식별 요구사항: 고정식별자 data-testid 대기 방법
          - 페이지 로드 식별 금지사항: networkidle 대기 방법 *← 식별 금지인 이유는 채팅과 같은 서버랑 계속 통신하는 페이지에서는 에러가 발생할 수 있기 때문*
        - 테스트 skip 대상 *← 아직 사진 보관함 페이지 만들지 않았으므로 테스트 대상 아님. 이건 정해진게 아니라 개발 구현 순서에 따라 유연하게 조정*
          - /pictures
      - 기능 구현 조건: 
        - layout의 각 영역을 클릭시, url.ts의 페이지URL에 정의된 경로로 이동할 것. *← 이미 만들어져 있는 페이지/URL 명시* 

## 라이브러리

### 1. 폼 & 검증 라이브러리
- 폼 라이브러리: `React-Hook-Form`
  ```bash
  npm install react-hook-form
  ```
- 검증 라이브러리: `Zod`
  ```bash
  npm install zod
  ```
- `React-Hook-Form`(폼 라이브러리)와 `Zod`(검증라이브러리) 연동 라이브러리
  ```bash
  npm install @hookform/resolvers
  ```

<br/>

# API 연동 기능
- 회원가입 UI + 회원가입 폼 (AI 디자인 + 내부 API)
- 로그인 UI + 로그인 폼 (AI 디자인)
- 인증 프로바이더 및 로그인 상태료시

## 디자인이 없는 경우 AI를 이용하여 디자인 생성
**1. 기존에 디자인이 있어야 함.** 
  - ex. 공통 컴포넌트, 공통컬러 등
**2. AI를 이용해서 디자인 하는 경우**
  -  wireframe을 prompt로 전달하는 과정은 생략함. wireframe 정보 자체가 없기 때문.
**3. 디자인 스타일에 대한 힌트 제공 필요**
  - ex.  페이지를 모던한 디자인 스타일로 구현할 것

## GraphQL
- Restful API와 동일하게 **API를 호출하는 방식** 중 하나

<details>

<summary>GraphQL 자세히</summary>

**1. 기본 개념**
- GraphQL은 페이스북에서 만든 API 질의 언어
- REST랑 차이점:
  - REST: 여러 개의 URL(엔드포인트) → 여러 번 요청
  - GraphQL: 하나의 URL → 필요한 데이터만 요청 가능
- Operation Type:
  - **Query**: 데이터 조회(GET)
  - **Mutation**: 데이터 생성/수정/삭제(POST, PUT, DELETE)
  - **Subscription**: 실시간 데이터 (웹소켓)
- 장점:
  - 필요한 데이터만 가져오기
  - 클라이언트 주도 요청
  - 타입이 명확 (Schema)

**2. 기본구조**
```
[Operation Type] {
  [API이름] ([Arguments]) {
    [Field Name1], # 필요한 필드만 요청 가능
    [Field Name2],
    [Field Name3], 
    ...
  }
}
```

- ex1. `Query`: 조회
  ```graphql
  query {
    fetchUser(email: "test1@gmail.com") { 
      _id
      name
      email
    }
  }
  ```

- ex2. `Mutation`: 생성
  ```graphql
  mutation {
    createUser(createUserInput: {
      email: "test1@gmail.com",
      password: "test1234!",
      name: "홍길동"
    }) {
      _id
      name
    }
  }
  ```

- ex3. Variables: 동적으로 값 변경
  ```graphql
  # Query
  query FetchUser($email: String!) {
    fetchUser(email: $email) {
      name
      email
    }
  }

  # Variables (JSON 형태)
  {
    "email": "test1@gmail.com"
  }
  ```
- `$email` → 변수
- `String!` → 필수
- GraphiQL에서는 우측 패널에 JSON 형태로 입력 가능

- ex4. Nested: 중첩 필드 요청
```graphql
query {
  fetchUser(email: "test1@gmail.com") {
    name
    posts {
      title
      comments {
        content
      }
    }
  }
}
```
- REST라면 /users/1/posts → /posts/1/comments 여러 요청 필요
- GraphQL은 한 번에 해결 가능

- ex4. Aliases & Fragments
```graphql
# Aliase: 같은 필드 다른 파라미터로 두 번 호출 가능
query {
  user1: fetchUser(email: "test1@gmail.com") {
    name
  }
  user2: fetchUser(email: "test2@gmail.com") {
    name
  }
}

# Fragments: 공통 필드 재사용 가능
fragment userInfo on User {
  _id
  name
  email
}

query {
  fetchUser(email: "test1@gmail.com") {
    ...userInfo
  }
  fetchUser(email: "test2@gmail.com") {
    ...userInfo
  }
}
```

</details>

## 사용 방법

### 1. GraphiQL 설치(Chrome Extension)
- [설치 링크](https://chromewebstore.google.com/detail/graphiql-extension/jhbedfdjpmemmbghfecnaeeiokonjclb)설치

### 2. GraphiQL 실행
- 주소창 옆에서 설치된 **GraphiQL extension** 선택

### 3. API의 주소 입력
- ex. https://main-practice.codebootcamp.co.kr/graphql

### 4. API 목록 확인
- 왼쪽의 `Documentation` 아이콘 선택

### 5. API 조회 방법
- API 종류:
  - `Query`: 상세 조회
  - `Mutation`: 입력 / 수정 / 삭제
- 사용 예시
  ```graphql
  # 유저 생성
  mutation {
    createUser (createUserInput: {
      email: "test1@gmail.com",
      password: "test1234!"
      name: "홍길동",
    }) {
      _id
    }
  }

  # 유저 조회
  query {
    fetchUser (email: "test1@gmail.com") {
      name
    }
  }
  ```

### 6. prompt에 입력
- 5단계에서 이미 API 동작을 확인했으므로,이제 AI에게 기능 구현을 요청할 수 있음   

  ``` md
  ...
  조건-파일경로) 참고할 API  문서경로: https://main-practice.codebootcamp.co.kr/graphql
  ...

  핵심요구사항) 다음의 조건에 맞게 회원가입 폼 등록 기능을 step-by-step 으로 구현하고, 적용 결과를 체크리스트로 반환할 것.
              1) 라이브러리조건
                  - 폼: 이미 설치되어있는 react-hook-form, @hookform/resolvers를 사용할 것.
                  - 검증: 이미 설치되어있는 zod를 사용할 것.
                  - API: 이미 설치되어있는 @tanstack/react-query를 사용할 것.

              2) 유저시나리오(회원가입)
                  1. 모든 인풋이 입력되면 회원가입버튼을 활성화 할 것.

                  2. 회원가입버튼을 누르면 회원가입API를 요청할 것.
                      2-1) API명: createUser
                      2-2) 요청데이터: createUserInput(email, password, name)
                      2-3) 응답데이터: { _id }
                      2-4) zod 검증 조건
                          - email: '@' 포함
                          - password: 영문 + 숫자 포함 8자리 이상
                          - passwordConfirm: password와 동일
                          - name: 최소 1글자 이상

                  3. 회원가입에 성공하면, 가입완료모달을 노출하고, 아래의 상황별 지시를 따를 것.
  ...

  ```

<br/>

# Guard 설계 및 접근 제어 구조

## 1. 개요

- Guard = **Authentication** (인증) + **Authorization** (인가) + **Conditional Access** (조건부 접근)
- 역할: 사용자의 상태, 권한, 조건에 따라 **페이지(Page)** 또는 **기능(Action)** 접근을 제한/허용하는 wrapper component
- 구분: 
  | 구분 | 의미  | Guard와의 관계 |
  | --- | ---- | ------------ |
  | **인증 (Authentication)**         | `로그인` 여부 확인               | Guard가 내부적으로 인증 상태를 확인할 수 있음 |
  | **인가 (Authorization)**          | 로그인된 사용자의 `권한` 확인 | Guard의 주요 역할 |
  | **조건부 접근 (Conditional Access)** | 구독, 설정, 플랜 등 기타 `조건`확인 | Guard에서 추가 로직 적용 가능 |

## 2. 역할과 종류

### 2-1. Guard 유형

| 구분                   | 설명            | 예시                         |
| -------------------- | ------------- | -------------------------- |
| **Authentication Guard** | 로그인 여부로 접근 제어 | 비로그인 → 마이페이지 접근 시 차단       |
| **Authorization Guard**  | Role 기반 접근 제어 | 관리자만 게시물 삭제 가능             |
| **Feature Guard**        | 특정 조건 (구독, 설정 등) 접근 제어   | 구독자만 통계 기능 이용 가능           |
| **Action Guard**         | 특정 행동 (버튼 클릭 등) 제어      | 비회원 → ‘글쓰기’ 클릭 시 로그인 Modal |

### 2-2. Page Guard vs Action Guard

| 구분               | 동작             | 시나리오 예시                                           |
| ---------------- | -------------- | ------------------------------------------------- |
| **Page Guard**   | 페이지 단위 접근 제어   | - /mypage 접근 시 비회원 → Modal 표시 → 로그인 → 원래 페이지 이동   |
| **Action Guard** | 버튼/기능 단위 접근 제어 | - ‘상품 등록하기’ 버튼 클릭 시 비회원 → Modal 표시 → 로그인 → 재시도 가능 |

<br/>

- 페이지 접근 플로우 예시:
  ```text
  [사용자 요청] → [Guard] → 인증/권한/조건 확인
      ├─ 통과 → [페이지 렌더링]
      └─ 불충족 → [Modal 표시] → 로그인/권한 획득 → [원래 페이지로 리다이렉트]
  ```

- 기능 실행 플로우 예시:
  ```text
  [버튼 클릭] → [Guard] → 인증/권한/조건 확인
      ├─ 통과 → [액션 수행]
      └─ 불충족 → [Modal 표시] → 로그인/권한 획득 → [버튼 재클릭]
  ```

## 3. 설계 가이드

### 3-1. Provider 트리 내 적용 예시
> Note: Guard는 Provder 레벨에서 동작하나 Provider는 아님.   
> Guard는 Context를 제공하지 않음 → Provider는 아니고, **Wrapper Component** 개념

```js
<AuthProvider>              // 로그인 상태 관리
  <ReactQueryProvider>      // 서버 데이터 캐싱
    <NextThemesProvider>    // 테마 관리
      <ModalProvider>       // 모달 상태 관리
        <Guard>             // 페이지/액션 접근 제어
          <Layout>
            {children}      // 실제 페이지
          </Layout>
        </Guard>
      </ModalProvider>
    </NextThemesProvider>
  </ReactQueryProvider>
</AuthProvider>
```

### 3-2. Guard 구조 설계

| 상황 | 구조 예시 | 설명 |
| ----| ------- | ---- |
| 단순 회원/비회원   | `/commons/providers/auth/auth.guard.tsx` | 단순 인증 확인 시 |
| 복수 권한(Role) | `/commons/providers/guard/guard.tsx`     | Role별 권한 로직 모듈화, Guard 전용 폴더 관리 |

### 3-3. 설계 주의사항
1. **UI + API 모두 적용**
   - 버튼 클릭 시 차단 + API 호출 시 인증 검증

2. **유저 시나리오/테스트 시나리오 충분히 설계**
    - 예: 비로그인 → 마이페이지 접근 → Modal → 로그인 → 접근
    - 예: 로그인 → 토큰 만료 → 자동 로그아웃 → 로그인 화면 이동

3. **조건/URL 상수 분리**
    - Page Guard: `/commons/constants/url.ts` 에서 Guard가 참고
    - Action Guard: 액션 가드를 먼저 만들고, 필요한 버튼에 적용

## 4. 테스트 전략

> 상세페이지 같은 페이지들이 회원 전용으로 바뀌면서 기존 작성했던 테스트들이 권한 문제에 부딪힘. ->   
> 그럼 기존 테스트는 어떻게 통과할 것인가? ->   
> 기존 테스트 코드들은 회원으로 가정하고, 앞으로 추가하는 테스트에는 비회원인 경우에 접속 불가능한지  확인하는 역케이스들만 작성 (Negative Test)

### 4-1. 테스트 케이스 구분

| 구분    | Positive / Negative | 검증 항목                    |
| ----- | ------------------- | ------------------------ |
| 비회원   | Negative            | 보호된 페이지 접근 시 Modal 표시    |
| 회원    | Positive            | 정상적으로 페이지 접근 및 기능 수행 가능  |
| 관리자   | Positive            | 관리자 전용 페이지 접근 가능         |
| 만료 토큰 | Negative            | Guard가 로그아웃/Redirect 처리  |
| 역테스트  | Negative            | 비회원이 기능 실행 시 Guard 정상 작동 |

### 4-2. 테스트 전략 시나리오 예시

1. 페이지 접근
    - 비회원 → /mypage 접근 → Modal 표시 → 로그인 → 원래 페이지 접근
    - 로그인 → /mypage 접근 → 정상 렌더링

2. 액션 접근
    - 비회원 → ‘글쓰기’ 버튼 클릭 → Modal → 로그인 → 버튼 재클릭 → 정상 수행
    - 구독 미충족 → 구독자 전용 기능 클릭 → Modal → 구독 후 기능 수행

<br/>

# Provider (프로바이더)
### 개요
- **Provider**는 React의 **Context API**를 활용해, **전역적으로 공유되어야 하는 데이터나 설정을 모든 하위 컴포넌트에 전달**하기 위한 컴포넌트.
- 즉, 각 페이지나 컴포넌트에서 동일한 설정을 일일이 반복하지 않도록 **공통 환경을 한 곳에서 관리**하기 위해 사용됨.

| 구분     | 설명                                                                 |
| ------ | ------------------------------------------------------------------ |
| **역할** | 하위 컴포넌트에 전역 데이터 또는 설정을 전달                                          |
| **구조** | `<Provider value={…}>{children}</Provider>` 형태                     |
| **장점** | 전역 상태 관리, 코드 중복 방지, 일관된 설정 제공                                      |
| **예시** | AuthProvider, ThemeProvider, Redux Provider, QueryClientProvider 등 |


### 사용목적
- 모든 페이지에 동일한 설정이나 데이터를 적용하고 싶을 때, 각 페이지마다 직접 전달하는 대신 Provider를 통해 전체 앱에 주입

- 예를 들어:

- 로그인 상태 (AuthProvider)
- 테마 설정 (ThemeProvider)
- 다국어 설정 (I18nProvider)
- 전역 상태 관리 (Redux Provider, QueryClientProvider 등)
- 공통 API 클라이언트 설정

### 동작원리
- rovider는 `children`을 감싸서, 그 안의 모든 하위 컴포넌트에 **Context** 값을 전달함.
```tsx
<AuthProvider>
  <ThemeProvider>
    <App />   {/* 모든 컴포넌트가 Auth, Theme 정보를 접근할 수 있음 */}
  </ThemeProvider>
</AuthProvider>
```
- 각 Provider 내부에서는 React의 createContext()와 useContext()를 사용해
공유할 데이터(상태, 함수 등)를 정의함.

<br/>

# 병렬 처리
- 독립적인 기능 선별: 메인페이지 기능, 상세페이지 기능.